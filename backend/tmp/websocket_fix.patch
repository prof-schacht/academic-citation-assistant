--- a/frontend/src/services/websocketService.ts
+++ b/frontend/src/services/websocketService.ts
@@ -20,11 +20,11 @@ export class CitationWebSocketClient {
   private reconnectDelay = 1000; // Start with 1 second
   private messageQueue: WSMessage[] = [];
   private userId: string;
-  private isConnected = false;
   private pingInterval: NodeJS.Timeout | null = null;
+  private connectionTimeout: NodeJS.Timeout | null = null;
   private config: CitationConfig = {
     useEnhanced: true,
     useReranking: true,
     searchStrategy: 'hybrid'
   };
   private callbacks: {
@@ -40,9 +40,14 @@ export class CitationWebSocketClient {
   }

   connect(): void {
-    if (this.socket?.readyState === WebSocket.OPEN) {
+    // Clear any existing connection timeout
+    if (this.connectionTimeout) {
+      clearTimeout(this.connectionTimeout);
+    }
+
+    if (this.socket?.readyState === WebSocket.OPEN || this.socket?.readyState === WebSocket.CONNECTING) {
+      console.log('[WebSocket] Already connected or connecting, skipping');
       return;
     }

@@ -62,12 +67,20 @@ export class CitationWebSocketClient {
     try {
       this.socket = new WebSocket(wsUrl);
       
+      // Set connection timeout
+      this.connectionTimeout = setTimeout(() => {
+        if (this.socket?.readyState !== WebSocket.OPEN) {
+          console.error('[WebSocket] Connection timeout after 5 seconds');
+          this.socket?.close();
+        }
+      }, 5000);
+      
       this.socket.onopen = () => {
         console.log('WebSocket connected');
-        this.isConnected = true;
+        clearTimeout(this.connectionTimeout!);
         this.reconnectAttempts = 0;
         this.reconnectDelay = 1000;
         
         // Send queued messages
         while (this.messageQueue.length > 0) {
@@ -101,8 +114,7 @@ export class CitationWebSocketClient {

       this.socket.onclose = () => {
         console.log('WebSocket disconnected');
-        this.isConnected = false;
+        clearTimeout(this.connectionTimeout!);
         this.stopPingInterval();
         this.callbacks.onDisconnect?.();
         
@@ -116,11 +128,15 @@ export class CitationWebSocketClient {

   disconnect(): void {
     this.stopPingInterval();
+    if (this.connectionTimeout) {
+      clearTimeout(this.connectionTimeout);
+      this.connectionTimeout = null;
+    }
     if (this.socket) {
-      this.socket.close();
+      if (this.socket.readyState === WebSocket.OPEN || this.socket.readyState === WebSocket.CONNECTING) {
+        this.socket.close();
+      }
       this.socket = null;
     }
-    this.isConnected = false;
     this.messageQueue = [];
   }

@@ -157,7 +173,7 @@ export class CitationWebSocketClient {
   }

   getConnectionStatus(): boolean {
-    return this.isConnected;
+    return this.socket?.readyState === WebSocket.OPEN;
   }

   /**
@@ -171,11 +187,16 @@ export class CitationWebSocketClient {
     this.config = { ...this.config, ...config };
     
     // Reconnect if configuration changed and we're connected
-    if (configChanged && this.isConnected) {
+    if (configChanged && this.socket?.readyState === WebSocket.OPEN) {
       console.log('[WebSocket] Configuration changed, reconnecting...');
       this.disconnect();
-      this.connect();
+      // Delay reconnection to avoid race conditions
+      setTimeout(() => {
+        this.connect();
+      }, 100);
     }
+  } else if (configChanged && !this.socket) {
+    // If no socket exists, just update config
   }

   /**
@@ -218,7 +239,11 @@ export class CitationWebSocketClient {
   private sendMessage(message: WSMessage): void {
     if (this.socket?.readyState === WebSocket.OPEN) {
       console.log('[WebSocket] Sending message:', message);
-      this.socket.send(JSON.stringify(message));
+      try {
+        this.socket.send(JSON.stringify(message));
+      } catch (error) {
+        console.error('[WebSocket] Error sending message:', error);
+      }
     } else {
       console.log('[WebSocket] Not connected, queueing message. ReadyState:', this.socket?.readyState);
       // Queue the message for later with a limit to prevent memory issues